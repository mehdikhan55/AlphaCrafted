import puppeteer from 'puppeteer';
import fs from 'fs';
import path from 'path';
import Handlebars from 'handlebars';
import dbConnect from '@/lib/dbConnect'; // Ensure this path is correct
import Resume from '@/models/resume'; // Import the Resume model
import { randomUUID } from 'crypto';
import { NextResponse } from 'next/server';

export const POST = async (req) => {
  try {
    const resumeData = await req.json();

    // Connect to the database
    await dbConnect();

    // Save to database
    const newResume = new Resume(resumeData);
    const savedResume = await newResume.save();

    // Path to the HTML template
    const templatePath = path.resolve('src/templates/resumeTemplate.html');
    const htmlTemplate = fs.readFileSync(templatePath, 'utf8');

    // Using Handlebars to compile the template with data
    const template = Handlebars.compile(htmlTemplate);
    const filledHtml = template(resumeData);

    // Ensuring the 'uploads/resumes' directory exists
    const uploadDir = path.resolve('src/uploads/resumes');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }

    // Define the file path for the generated resume
    const uniqueId = randomUUID();
    const filePath = path.join(uploadDir, `resume-${resumeData.fullName.replace(/\s+/g, '-')}-${uniqueId}.pdf`);

    // Generate the PDF using Puppeteer
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.setContent(filledHtml);
    await page.pdf({ path: filePath, format: 'A4' });
    await browser.close();

    // Update the saved resume document with the PDF path
    savedResume.pdfPath = filePath;
    await savedResume.save();

    return NextResponse.json({ filePath }, { status: 200 });
  } catch (error) {
    console.error('API route error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
};
